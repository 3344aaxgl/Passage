---
layout: post
title:  "UNIX网络编程"
date:   2018-07-12 14:54:51 +0800
categories: unix_network_programming
tags: c++
description: unix network programming读书笔记
---


## 传输层：TCP、UPD和SCTP

### 总图

虽然协议族被称为TCP/IP，但除了TCP和IP这两个主要协议外，还有许多其他成员。

* IPv4 网际协议版本4。使用32位地址。IPv4给TCP、UDP、ICMP和IGMP提供分组递送服务。
* IPv6 网际协议版本6。使用128位地址。IPv6给TCP、UDP、ICMP和IGMP提供分组递送服务。
* TCP 传输控制协议。TCP是一个面向连接的协议，为用户进程提供可靠的全双工字节流。TCP套接字是一种流套接字，TCP关心确认，超时和重传之类的细节。
* UDP 用户数据报协议。UDP是一个无连接协议。UDP套接字是一种数据报套接字。UDP数据报不保证最终到达他们的目的地。
* SCTP 流控制传输协议。SCTP提供一个可靠全双工关联的面向连接的协议。SCTP是多宿的，从而每个关联的两端均涉及一族IP和一个端口号。SCTP提供消息服务，也就是维护来自应用层的。
* ICMP 网际控制消息协议。ICMP处理再路由器和主机直接流通的错误和控制消息。这些消息通常由TCP/IP网络支持软件本身产生和处理。但ping和tracerouter程序同样适用ICMP。
* IGMP 网际组管理协议。IGMP用于多播。
* ARP 地址解析协议。ARP把一个IPv4地址映射成一个硬件地址。
* RARP 反向地址解析协议。RARP把一个硬件地址映射成一个IPv4地址。
* ICMPv6 网际控制消息协议版本6。ICMPv6总和IPv4、IGMP和ARP的功能。
* BPF BSD分组过滤器。该接口提供对于数据链路层的访问能力。
* DLPI 数据链路提供者接口。该接口也提供对数据链路层的访问。

### 用户数据报协议（UDP）

UDP是一个简单的传输层协议，应用层往一个UDP套接字写入一个消息，该消息随后被封装到一个UDP数据报，该UDP数据报进而又被封装到一个IP数据报，然后发送到目的地。UDP不保证UDP数据报会到达其最终目的地。不保证各个数据报的顺序跨网络后保持不变，也不保证每个数据报只到达一次。

每个UDP数据报都有一个长度。如果一个数据报正确地到达其目的地，那么该数据报的长度将随数据一道传递给接收端应用进程。而TCP是一个字节流协议，没有任何记录边界。

UDP是无连接服务的，因为UDP客户与服务器之间不必存在任何长期的的关系。

### 传输控制协议（TCP）

* TCP提供客户与服务器之间的连接。
* TCP提供可靠性。当TCP向另一端发送数据时，要求对端返回一个确认。如果没有收到确认，TCP就自动重传数据并等待更长的时间。在数次重传失败后，TCP才放弃。TCP含有动态估算客户和服务器之间的往返时间的算法。

TCP通过给其中每个字节关联一个序号对所发送的数据进行排序。假设一个应用写2048个字节到一个TCP套接字，导致TCP发送两个分节：第一个分节所含数据的序号为1~1024,第二个分节所含数据的序列号为1025~2048。如果这些分节非顺序到达，接收端的TCP将根据他们的序列号重新排序，再把结果数据传递给应用层。如果接收端TCP收到来自对端的重复数据，可以根据序列号判断数据是重复的从而丢弃重复数据。

* TCP提供流量控制。TCP总是告知对端在任何时刻它一次能从对端接收多少字节的数据，这成为通告窗口。在任何时刻，该窗口指出当前可用的空间量，从而确保发送端的数据不会使接收缓冲区溢出。

### TCP连接的建立和终止

**三路握手**

建立一个TCP连接时会发生下述情形：

* 服务器必须准备好接收外来的连接。这通常通过调用socket,bind,listen这3个函数来完成，我们称之为被动打开。
* 客户通过调用connect发起主动打开。这导致客户TCP发送一个SYN分节，告诉服务器将在连接中发送数据的初始序列号。
* 服务器必须确认（ACK）客户的SYN，同时字节也得发送一个SYN分节，它含有服务在同一连接中发送的数据的初始序列号。服务器在一个分节中发送SYN和对客户SYN的ACK。
* 客户必须确认服务器的SYN

![2-1.png](2-1.png)

ACK中的确认号是发送这个ACK这一端所期待的下一个序列号。

**TCP选项**

* MSS选项。发送SYN的TCP一端使用本选项通告对端它的最大分节大小，即MSS。也就是它在本连接的每个TCP分节愿意接受的最大数据量。发送端TCP使用接收端的MSS值作为所发送字节的最大大小。
* 窗口规模选项。TCP连接任何一端能通告对端的最大窗口大小是65535，因为在TCP首部中相应的字段占16位。
* 时间戳选项。这个选项对于高速网络连接是必要的，它可以防止失而复现的分组可能造成的数据破坏。

**TCP连接的终止**

* 某个应用进程首先调用close，我们称该端执行主动关闭。该端的TCP于是发送一个FIN分节，表示数据发送完毕。
* 接收到这个FIN的对端执行被动关闭。这个FIN由TCP确认。它的接收也作为一个文件描述符传递给接收端应用进程，因为FIN的接收意味着接收端应用进程在相应的连接上再无额外的数据可以接收。
* 过一段时间后，收到这个文件结束符的应用进程将调用close关闭它的套接字。
* 接收这个FIN的原发送端确认这个FIN。

![2-2.png](2-2.png)

在步骤2和3之间，从执行被动关闭一端到主动关闭一端流动数据是可能的。这称为半关闭。

**TCP状态转换图**

![2-3.png](2-3.png)

**观察分组**

本例中的客户通告一个值为536的MSS，服务端通告一个值为1460的MSS。不同方向上的MSS不同不成问题。

![2-4.png](2-4.png)

图中服务器对客户请求的确认是伴随其应答一起发送的，这种做法称为捎带，它通常在服务器处理请求并产生应答少于200ms时发生。

### TIME_WAIT状态

端点停留在这个状态的持续时间是最长分节生命期的两倍，称为2MSL。

TIME_WAIT存在有两个理由：

* 可靠的实现TCP全双工连接的终止

如果最后一个ACK丢失了，那么服务器端将再次发送FIN，客户这边也需要重新发送ACK。如果客户不等待，那么将响应一个RST分节。

* 允许老的重复节点在网络中消逝

如果在关闭这个连接后，在这个套接字对上重新建立连接，TCP必须防止来自某个连接的老的重复数据在该连接已终止后再现，从而被误解成属于这个新的连接。上一个连接的老的分节最多存活MSL秒就会被丢弃。

### 端口号

* 众所周知的端口为0~1023。这些端口由IANA分配和控制。可能的话，相同的端口就分配给TCP、UDP和SCTP的同一给定服务。
* 已登记的端口为1024~49151。这些端口不收IANA的控制。
* 49152~65535是动态的或私有的端口

**套接字对**

一个TCP的套接字对是一个定义该连接的两个端点的四元组：本地IP地址，本地TCP端口号，外地IP地址，外地TCP端口号。

### TCP端口号和并发服务器

TCP无法仅仅通过查看目的端口号来分离外来的分节到不同的端点。它必须查看套接字对的所有4个元素才能确定由哪个端点接收某个到达的分节。所以不同的客户可以连接到同一个服务器的同一个端点上，服务器会在每一次accept后返回一个新的已连接套接字。

### 缓冲区大小及限制

* IPv4数据报的最大大小是65535字节，包括IPv4首部。
* IPv6数据报最大大小是65575字节，包括40字节IPv6首部。
* 许多网络有一个可由硬件规定的MTU，以太网MTU为1500字节。IPv4要求的最小链路MTU为68，IPv6要求的最小链路为1280。
* 在两个主机之间的路径中最小的MTU成为路径MTU。
* 当一个IP数据报将从某个接口送出时，如果它的大小超过相应链路的MTU，IPv4和IPv6都将执行分片。这些片段在到达最终目的地之前通常都不会被重组。
* IPv4首部的“不分片”位若被设置，那么不管是发送这些数据报的主机还是转发他们的路由器，都不允许对他们分片。当路由器接到一个超过其外出链路MTU且设置了不分片未的IPv4数据报时，它将产生一个ICMPv4“目的地不可达，需分片但DF位已设置”。
* IPv4和IPv6都定义了最小重组缓冲区大小。它是IPv4或IPv6任何实现都必须保证支持的最小数据报大小。其值对于IPv4为576字节，对于IPv6为1500字节。
* TCP有一个MSS，用于向对端TCP通告对端在每个分节中能发送的TCP数据量。MSS的目的是告诉对端其重组缓冲区大小的实际值。从而试图避免分片。MSS经常被设置为MTU减去IP和TCP的首部的固定长度。在以太网中使用IPv4的MSS值为1460，使用IPv6的MSS值为1440。MSS是一个16位的字段，限定其最大值为65535。

#### TCP输出

每一个TCP套接字有一个发送缓冲区，我们可以使用SO_SNDBUF套接字选项来更改缓冲区的大小。当某个应用进程调用write时，内核从该缓冲区中复制所有数据写到套接字的发送缓冲区。如果该套接字的发送缓冲区容不下该应用进程的所有数据，该应用进程将被将被投入睡眠。直到应用进程缓冲区中的所有数据都被复制到套接字发送缓冲区。因此从写一个TCP套接字的write调用成功返回仅仅表示我们可以重新使用原来的应用进程缓冲区，并不表示对端的TCP或应用进程已经接收到数据。TCP必须为已发送的数据保留一个副本，直到它被对端确认。

### UDP输出

如果应用进程写一个大于套接字缓冲区大小的数据报，内核将返回进程一个EMSGSIZE错误。UDP是不可靠的，不必保存应用进程数据的一个副本，因此无需一个真正的发送缓冲区。如果某个UDP应用进程发送大数据报，那么相比于TCP应用数据更有可能被分片，因为TCP会把应用数据划分成MSS大小的块，而UDP没有对等的手段。

从写一个UDP套接字的write调用成功返回表示所写的数据报或所有的分片已加入数据链路层的输出队列。如果该队列没有足够的空间存放该数据报或它的某个片段，内核通常会返回一个ENOBUFS的错误给它的应用进程。