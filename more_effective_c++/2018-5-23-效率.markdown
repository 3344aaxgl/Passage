---
layout: post
title:  "效率"
date:   2018-05-23 20:56:51 +0800
categories: more_effective_c++
tags: c++
description: more effective c++读书笔记
---

## 牢记80－20准则（80－20 rule）

80－20准则说的是大约20％的代码使用了80％的程序资源；大约20%的代码耗用了大约80％的运行时间；大约20％的代码使用了80％的内存；大约20％的代码执行80％的磁盘访问；80％的维护投入于大约20％的代码上；

用profiler程序识别出令人讨厌的程序的20％部分

## 考虑使用lazy evaluation（懒惰计算法）

* 除非你确实需要，不去为任何东西制作拷贝。我们应该是懒惰的，只要可能就共享使用其它值。
* 区别对待读取和写入
* Lazy Fetching（懒惰提取）

可以使用const_cast来实现mutable关键字的功能

{% highlight c++ %}

const string& LargeObject::field1() const
{
// 声明指针, fakeThis, 其与this指向同样的对象
// 但是已经去掉了对象的常量属性
LargeObject * const fakeThis =
const_cast<LargeObject* const>(this);
if (field1Value == 0) {
fakeThis->field1Value = // 这赋值是正确的,
the appropriate data // 因为fakeThis指向的
from the database; //对象不是const
}
return *field1Value;
}
{% endhighlight %}

* Lazy Expression Evaluation(懒惰表达式计算)

## 分期摊还期望的计算

caching(缓存)那些已经被计算出来而以后还有可能需要的值。

STL预分配更多的内存

## 理解临时对象的来源

未命名的对象通常在两种条件下产生：为了使函数成功调用而进行隐式类型转换和函数返回对象时。

### 函数成功调用而进行隐式类型转换

仅当通过传值（by value）方式传递对象或传递常量引用（reference-to-const）参数时，才会发生这些类型转换。当传递一个非常量引用（reference-to-non-const）参数对象，就不会发生。如果非常量引用发生隐式转换，那额修改值并不是期望的非常量引用

{% highlight c++ %}

int Countchar(const string& str)
{
    cout<<"const string&"<<endl;
    return str.length();
}

int Count(string str)     //重载冲突
{
    cout<<" string"<<endl;
    return str.length();
}

int Countsize(string& str)     //无法进行隐式转换
{
    cout<<" string"<<endl;
    return str.length();
}
int main()
{
    char arr[] = {"hello world"};
    cout<<Countchar(arr)<<endl;
    cout<<Count(arr)<<endl;
    cout<<Count(arr)<<endl;
    //cout<<Countsize(arr)<<endl;//无法进行转换
    return 0;
}
{% endhighlight %}

### 函数返回对象

函数的返回值是临时的，因为它没有被命名；它只是函数的返回值。只要见到函数返回对象，就会有一个临时对象被建立（以后被释放）

## 协助完成返回值优化

无法通过返回引用和指针来进行返回值优化，因为局部对象在函数退出之后就被释放了，引用和指针都不能再被使用。

正确做法是通过编译器的RVO(返回值优化)和NRVO（命名返回值优化）

{% highlight c++ %}
class A
{
public:
  A(int i):data(i)
  {
      cout<<"called constructor"<<endl;
  }
  A(A&& a)
  {
      cout<<"called move constructor"<<endl;  
      if(&a == this)
        return ;
      else
      {
      
      }
  }
  ~A()
  {
      cout<<"called deconstructor"<<endl;
  }
private:
  int data;
};

A RVOTest(int i)//RVO
{
    return A(i);
}

A NRVOTest(int i)//NRVO
{
    A a(i);
    return a;
}
int main()
{
    A a = RVOTest(1);
    A b = NRVOTest(2);
    return 0;
}
{% endhighlight %}

两次函数调用都只创建和释放了一个对象，分别创建了a和b，没有建立临时对象。编译器在为目标a，b分配的内存里构造return表达式定义的对象。