---
layout: post
title:  "线程间共享数据"
date:   2018-05-26 14:03:51 +0800
categories: cpp_concurrency_in_action
tags: c++
description: cpp concurrency in action读书笔记
---


## 3.1 共享数据带来的问题

线程间潜在问题就是修改共享数据，致使不变量遭到破坏。

### 3.1.1 条件竞争

恶性条件竞争通常发生于完成对多于一个的数据块的修改时，因为操作要访问两个独立的数据块，独立的指令将会对数据块将进行修改，并且其中一个线程可能正在进行时，另一个线程就对数据块进行了访问。因为出现的概率太低，条件竞争很难查找，也很难复现。

条件竞争通常是时间敏感的，所以程序以调试模式运行时，它们常会完全消失，因为调试模式会影响程序的执行时间

### 3.1.2 避免恶性条件竞争

解决恶性条件竞争：
   * 对数据结构采用某种保护机制，确保只有进行修改的线程才能看到不变量被破坏时的中间状态。从其他访问线程的角度来看，修改不是已经完成了，就是还没开始。
   * 对数据结构和不变量的设计进行修改，修改完的结构必须能完成一系列不可分割的变化，也就是保证每个不变量保持稳定的状态，这就是所谓的无锁编程。

## 3.2 使用互斥量保护共享数据

当访问共享数据前，使用互斥量将相关数据锁住，再当访问结束后，再将数据解锁。线程库需要保证，当一个线程使用特定互斥量锁住共享数据时，其他的线程想要访问锁住的数据，都必须等到之前那个线程对数据进行解锁后，才能进行访问。这就保证了所有线程能看到共享数据，而不破坏不变量。

### 3.2.1 C++中使用互斥量

C++中通过实例化 std::mutex 创建互斥量，通过调用成员函数lock()进行上锁，unlock()进行解锁。不过，不推荐实践中直接去调用成员函数，因为调用成员函数就意味着，必须记住在每个函数出口都要去调用unlock()，也包括异常的情况。C++标准库为互斥量提供了一个RAII语法的模板类 std::lock_guard ，其会在构造的时候提供已锁的互斥量，并在析构的时候进行解锁，从而保证了一个已锁的互斥量总是会被正确的解锁。

{% highlight c++ %}

void add_to_list(int new_value)
{
    std::lock_guard<std::mutex> guard(some_mutex);//析构函数自动释放互斥量
    some_list.push_back(new_value);
}

bool list_contains(int value_to_find)
{
    std::lock_guard<std::mutex> guard(some_mutex);
    return std::find(some_list.begin(),some_list.end(),value_to_find) != some_list.end();
}

int main()
{
    std::vector<std::thread> threads(3);

    for(int i = 0; i < 3; i++)
    {
        threads[i] = std::thread(add_to_list, i+1);
    }

    for_each(threads.begin(),threads.end(),std::mem_fn(&std::thread::join));

    std::cout<<list_contains(4)<<" "<<list_contains(3);

    return 0;
}
{% endhighlight %}

### 3.2.2 精心组织代码来保护共享数据

{% highlight c++ %}

class some_data
{
private:
  int a;
  std::string b;
public:
  void do_something()
  {

  } 
};

class data_wrapper
{
  private:
    some_data data;
    std::mutex m;

  public:
    template <typename Fundction>
    void process_data(Fundction func)
    {
        std::lock_guard<std::mutex> l(m);//互斥保护
        func(data);
    }
};

some_data* unprotected;

void malicious_function(some_data& data)
{
    unprotected = &data;   //得到成员指针
}

data_wrapper x;

void foo()
{
    x.process_data(malicious_function);
    unprotected->do_something();
}
{% endhighlight %}


切勿将受保护数据的指针或引用传递到互斥锁作用域之外，无论是函数返回值，还是存储在外部可见内存，亦或是以参数的形式传递到用户提供的函数中去。

### 3.2.3 发现接口内在的条件竞争

在栈中，pop操作需先判断栈是否为空，然后取值，最后删除节点。但在判断为空与取值之间，取值与删除节点之间，都可能存在条件竞争，所以需要同一互斥量去保护这些操作。而且如果先删除节点，再返回其值时，如果拷贝数据出错，则数据丢失。需要先进行拷贝，然后在删除（RCU）


