---
layout: post
title:  "C++内存模型和原子类型操作"
date:   2018-06-10 22:03:51 +0800
categories: cpp_concurrency_in_action
tags: c++
description: cpp concurrency in action读书笔记
---

## 5.1 内存模型基础

这里从两方面来讲内存模型:一方面是基本结构,这与事务在内存中是怎样布局的有关;另一方面就是并发。

### 5.1.1 对象和内存位置

1. 每一个变量都是一个对象，包括作为其成员变量的对象。
2. 每个对象至少占有一个内存位置。
3. 基本类型都有确定的内存位置(无论类型大小如何，即使他们是相邻的，或是数组的一部
分)。
4. 相邻位域是相同内存中的一部分。

### 5.1.2 对象、内存位置和并发

为了避免条件竞争，两个线程就需要一定的执行顺序。第一种方式，如第3章所述那样，使用互斥量来确定访问的顺序；当同一互斥量在两个线程同时访问前被锁住，那么在同一时间内就只有一个线程能够访问到对应的内存位置，所以后一个访问必须在前一个访问之后。另一种方式是使用原子操作同步机制，决定两个线程的访问顺序。

### 5.1.3 修改顺序

投机执行是不允许的，因为当线程按修改顺序访问一个特殊的输入，之后的读操作，必须由线程返回较新的值，并且之后的写操作必须发生在修改顺序之后。同样的，在同一线程上允许读取对象的操作，要不返回一个已写入的值，要不在对象的读取后再写入另一个值。

## 5.2 C++ 中的原子操作和原子类型

原子操作是个不可分割的操作。在系统的所有线程中，你是不可能观察到原子操作完成了一半这种情况的；它要么就是做了，要么就是没做，只有这两种可能。

### 5.2.1 标准原子类型

标准原子类型定义在头文件 <atomic> 中。这些类型上的所有操作都是原子的，在语言定义中只有这些类型的操作是原子的，不过可以用互斥锁来模拟原子操作。实际上，标准原子类型自己的实现就可能是这样模拟出来的：它们(几乎)都有一个 is_lock_free() 成员函数，这个函数让用户可以查询某原子类型的操作是直接用的原子指令( x.is_lock_free() 返回 true )， 还是编译器和库内部用了一个锁( x.is_lock_free() 返回 false )。

只有std::atomic_flag 类型不提供is_lock_free()成员函数。这个类型是一个简单的布尔标志，并且在这种类型上的操作都需要是无锁的；在 std::atomic_flag 对象明确初始化后，做查询和设置(使用test_and_set()成员函数)，或清除(使用clear()成员函数)都很容易。

剩下的原子类型都可以通过特化 std::atomic<> 类型模板而访问到，并且拥有更多的功能，但可能不都是无锁的。

标准原子类型是不能拷贝和赋值，他们没有拷贝构造函数和拷贝赋值操作。但是，因为可以隐式转化成对应的内置类型，所以这些类型依旧支持赋值，可以使用load()和store()成员函数，exchange()、compare_exchange_weak()和compare_exchange_strong()。它们都
支持复合赋值符：+=, -=, *=, |= 等等。并且使用整型和指针的特化类型还支持 ++ 和 --。当
然，这些操作也有功能相同的成员函数所对应：fetch_add(), fetch_or() 等等。

std::atomic<> 类模板不仅仅一套特化的类型，其作为一个原发模板也可以使用用户定义类型创建对应的原子变量。因为，它是一个通用类模板，操作被限制为load(),store()(赋值和转换为用户类型), exchange(), compare_exchange_weak()和compare_exchange_strong()。

每种函数类型的操作都有一个可选内存排序参数，这个参数可以用来指定所需存储的顺序。

1. Store操作，可选如下顺序：memory_order_relaxed, memory_order_release,
memory_order_seq_cst。
2. Load操作，可选如下顺序：memory_order_relaxed, memory_order_consume,
memory_order_acquire, memory_order_seq_cst。
3. Read-modify-write(读-改-写)操作，可选如下顺序：memory_order_relaxed,
memory_order_consume, memory_order_acquire, memory_order_release,
memory_order_acq_rel, memory_order_seq_cst。所有操作的默认顺序都是memory_order_seq_cst。

### 5.2.2 std::atomic_flag的相关操作

std::atomic_flag 是最简单的标准原子类型，它表示了一个布尔标志。这个类型的对象可以在两个状态间切换：设置和清除。

std::atomic_flag 类型的对象必须被ATOMIC_FLAG_INIT初始化。std::atomic_flag可以销毁，清除或设置。这些事情对应的函数分别是：clear()成员函数，和test_and_set()成员函数。clear()和test_and_set()成员函数可以指定好内存顺序。clear()是一个存储操作，所以不能有memory_order_acquire或memory_order_acq_rel语义，但是test_and_set()是一个“读-改-写”操作，所有可以应用于任何内存顺序标签。每一个原子操作，默认的内存顺序都是memory_order_seq_cst。

{% highlight c++ %}

class spinclock_mutex
{
  private:
    std::atomic_flag flag;
  public:
    spinclock_mutex():flag(ATOMIC_FLAG_INIT)
    {

    }

    void lock()
    {
        while(flag.test_and_set(std::memory_order_acquire));
    }

    void unlock()
    {
        flag.clear(std::memory_order_release);
    }
};

void fun(int n, spinclock_mutex &sp)
{
    for (int i = 0; i < 100; i++)
    {
        sp.lock();
        std::cout << "Now it's thread " << n << '\n';
        sp.unlock();
    }
}

void test_spinlock()
{
    spinclock_mutex sp;
    std::vector<std::thread> v;
    for(int i = 0; i < 10; i++)
      //传入入参，调用构造函数
      v.emplace_back(fun,i,std::ref(sp));
    
    for(auto& t : v)
      t.join();
}
{% endhighlight %}

### 5.2.3 std::atomic的相关操作

使用store()去写入(true或false)还是好于std::atomic_flag中限制性很强的clear()。同样的，test_and_set()函数也可以被更加通用的exchange()成员函数所替换，exchange()成员函数允许你使用你新选的值替换已存储的值，并且自动的检索原始值。std::atomic<bool> 也支持对值的普通(不可修改)查找，其会将对象隐式的转换为一个普通的bool值，或显示的调用load()来完成。

“比较/交换”操作是原子类型编程的基石；它比较原子变量的当前值和一个期望值，当两值相等时，存储提供值。当两值不等，期望值就会被更新为原子变量中的值。

对于compare_exchange_weak()函数，当原始值与预期值一致时，存储也可能会不成功；在这个例子中变量的值不会发生改变，并且compare_exchange_weak()的返回是false。

另一方面，如果实际值与期望值不符，compare_exchange_strong()就能保证值返回false。

一次失败的“比较/交换”将不会进行存储，所以“比较/交换”操作不能拥有memeory_order_release或memory_order_acq_rel语义。

你也不能提供比成功顺序更加严格的失败内存顺序；当你需要memory_order_acquire或memory_order_seq_cst作为失败语序，那必须要如同“指定它们是成功语序”那样去做。

std::atomic<bool> 和 std::atomic_flag 的不同之处在于， std::atomic<bool> 不是无锁的；
为了保证操作的原子性，其实现中需要一个内置的互斥量。当处于特殊情况时，你可以使用is_lock_free()成员函数，去检查 std::atomic<bool> 上的操作是否无锁。这是另一个，除了 std::atomic_flag 之外，所有原子类型都拥有的特征。

{% highlight c++ %}

bool expect = true;
std::atomic_bool b;
while(!b.compare_exchange_weak(expect,false));
{% endhighlight %}
