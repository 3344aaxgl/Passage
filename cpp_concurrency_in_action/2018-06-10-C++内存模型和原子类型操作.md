---
layout: post
title:  "C++内存模型和原子类型操作"
date:   2018-06-10 22:03:51 +0800
categories: cpp_concurrency_in_action
tags: c++
description: cpp concurrency in action读书笔记
---

## 5.1 内存模型基础

这里从两方面来讲内存模型:一方面是基本结构,这与事务在内存中是怎样布局的有关;另一方面就是并发。

### 5.1.1 对象和内存位置

1. 每一个变量都是一个对象，包括作为其成员变量的对象。
2. 每个对象至少占有一个内存位置。
3. 基本类型都有确定的内存位置(无论类型大小如何，即使他们是相邻的，或是数组的一部
分)。
4. 相邻位域是相同内存中的一部分。

### 5.1.2 对象、内存位置和并发

为了避免条件竞争，两个线程就需要一定的执行顺序。第一种方式，如第3章所述那样，使用互斥量来确定访问的顺序；当同一互斥量在两个线程同时访问前被锁住，那么在同一时间内就只有一个线程能够访问到对应的内存位置，所以后一个访问必须在前一个访问之后。另一种方式是使用原子操作同步机制，决定两个线程的访问顺序。

### 5.1.3 修改顺序

投机执行是不允许的，因为当线程按修改顺序访问一个特殊的输入，之后的读操作，必须由线程返回较新的值，并且之后的写操作必须发生在修改顺序之后。同样的，在同一线程上允许读取对象的操作，要不返回一个已写入的值，要不在对象的读取后再写入另一个值。

## 5.2 C++ 中的原子操作和原子类型

原子操作是个不可分割的操作。在系统的所有线程中，你是不可能观察到原子操作完成了一半这种情况的；它要么就是做了，要么就是没做，只有这两种可能。

### 5.2.1 标准原子类型

标准原子类型定义在头文件 <atomic> 中。这些类型上的所有操作都是原子的，在语言定义中只有这些类型的操作是原子的，不过可以用互斥锁来模拟原子操作。实际上，标准原子类型自己的实现就可能是这样模拟出来的：它们(几乎)都有一个 is_lock_free() 成员函数，这个函数让用户可以查询某原子类型的操作是直接用的原子指令( x.is_lock_free() 返回 true )， 还是编译器和库内部用了一个锁( x.is_lock_free() 返回 false )。

只有std::atomic_flag 类型不提供is_lock_free()成员函数。这个类型是一个简单的布尔标志，并且在这种类型上的操作都需要是无锁的；在 std::atomic_flag 对象明确初始化后，做查询和设置(使用test_and_set()成员函数)，或清除(使用clear()成员函数)都很容易。

剩下的原子类型都可以通过特化 std::atomic<> 类型模板而访问到，并且拥有更多的功能，但可能不都是无锁的。

标准原子类型是不能拷贝和赋值，他们没有拷贝构造函数和拷贝赋值操作。但是，因为可以隐式转化成对应的内置类型，所以这些类型依旧支持赋值，可以使用load()和store()成员函数，exchange()、compare_exchange_weak()和compare_exchange_strong()。它们都
支持复合赋值符：+=, -=, *=, |= 等等。并且使用整型和指针的特化类型还支持 ++ 和 --。当
然，这些操作也有功能相同的成员函数所对应：fetch_add(), fetch_or() 等等。

std::atomic<> 类模板不仅仅一套特化的类型，其作为一个原发模板也可以使用用户定义类型创建对应的原子变量。因为，它是一个通用类模板，操作被限制为load(),store()(赋值和转换为用户类型), exchange(), compare_exchange_weak()和compare_exchange_strong()。

每种函数类型的操作都有一个可选内存排序参数，这个参数可以用来指定所需存储的顺序。

1. Store操作，可选如下顺序：memory_order_relaxed, memory_order_release,
memory_order_seq_cst。
2. Load操作，可选如下顺序：memory_order_relaxed, memory_order_consume,
memory_order_acquire, memory_order_seq_cst。
3. Read-modify-write(读-改-写)操作，可选如下顺序：memory_order_relaxed,
memory_order_consume, memory_order_acquire, memory_order_release,
memory_order_acq_rel, memory_order_seq_cst。所有操作的默认顺序都是memory_order_seq_cst。

### 5.2.2 std::atomic_flag的相关操作

std::atomic_flag 是最简单的标准原子类型，它表示了一个布尔标志。这个类型的对象可以在两个状态间切换：设置和清除。

std::atomic_flag 类型的对象必须被ATOMIC_FLAG_INIT初始化。std::atomic_flag可以销毁，清除或设置。这些事情对应的函数分别是：clear()成员函数，和test_and_set()成员函数。clear()和test_and_set()成员函数可以指定好内存顺序。clear()是一个存储操作，所以不能有memory_order_acquire或memory_order_acq_rel语义，但是test_and_set()是一个“读-改-写”操作，所有可以应用于任何内存顺序标签。每一个原子操作，默认的内存顺序都是memory_order_seq_cst。

{% highlight c++ %}

class spinclock_mutex
{
  private:
    std::atomic_flag flag;
  public:
    spinclock_mutex():flag(ATOMIC_FLAG_INIT)
    {

    }

    void lock()
    {
        while(flag.test_and_set(std::memory_order_acquire));
    }

    void unlock()
    {
        flag.clear(std::memory_order_release);
    }
};

void fun(int n, spinclock_mutex &sp)
{
    for (int i = 0; i < 100; i++)
    {
        sp.lock();
        std::cout << "Now it's thread " << n << '\n';
        sp.unlock();
    }
}

void test_spinlock()
{
    spinclock_mutex sp;
    std::vector<std::thread> v;
    for(int i = 0; i < 10; i++)
      //传入入参，调用构造函数
      v.emplace_back(fun,i,std::ref(sp));
    
    for(auto& t : v)
      t.join();
}
{% endhighlight %}

### 5.2.3 std::atomic的相关操作

使用store()去写入(true或false)还是好于std::atomic_flag中限制性很强的clear()。同样的，test_and_set()函数也可以被更加通用的exchange()成员函数所替换，exchange()成员函数允许你使用你新选的值替换已存储的值，并且自动的检索原始值。std::atomic<bool> 也支持对值的普通(不可修改)查找，其会将对象隐式的转换为一个普通的bool值，或显示的调用load()来完成。

“比较/交换”操作是原子类型编程的基石；它比较原子变量的当前值和一个期望值，当两值相等时，存储提供值。当两值不等，期望值就会被更新为原子变量中的值。

对于compare_exchange_weak()函数，当原始值与预期值一致时，存储也可能会不成功；在这个例子中变量的值不会发生改变，并且compare_exchange_weak()的返回是false。

另一方面，如果实际值与期望值不符，compare_exchange_strong()就能保证值返回false。

一次失败的“比较/交换”将不会进行存储，所以“比较/交换”操作不能拥有memeory_order_release或memory_order_acq_rel语义。

你也不能提供比成功顺序更加严格的失败内存顺序；当你需要memory_order_acquire或memory_order_seq_cst作为失败语序，那必须要如同“指定它们是成功语序”那样去做。如果你没有指定失败的语序，那就假设和成功的顺序是一样的.

std::atomic<bool> 和 std::atomic_flag 的不同之处在于， std::atomic<bool> 不是无锁的；
为了保证操作的原子性，其实现中需要一个内置的互斥量。当处于特殊情况时，你可以使用is_lock_free()成员函数，去检查 std::atomic<bool> 上的操作是否无锁。这是另一个，除了 std::atomic_flag 之外，所有原子类型都拥有的特征。

{% highlight c++ %}

bool expect = true;
std::atomic_bool b;
while(!b.compare_exchange_weak(expect,false));
{% endhighlight %}

### 5.2.4 std::atomic:指针运算

原子指针类型，可以使用内置类型或自定义类型T，通过特化 std::atomic<T*> 进行定义。不能拷贝构造，
也不能拷贝赋值，但是他可以通过合适的类型指针进行构造和赋值。如同成员函数is_lock_free()一样， std::atomic<T*> 也有load(), store(), exchange(),compare_exchange_weak()和compare_exchage_strong()成员函数。std::atomic<T*> 为指针运算提供新的操作。基本操作有fetch_add()和fetch_sub()提供，它们在存储地址上做原子加法和减法，为+=, -=, ++和--提供简易的封装。

{% highlight c++ %}

Foo f[5];
std::atomic<Foo*> p(f);
Foo* x = p.fetch_add(2);
assert(x == f);
assert(p.load() == &f[2]);
x = (p -= 1);
assert(x == &f[1]);
assert(p.load() == &f[1]);
{% endhighlight %}

### 5.2.5 标准的原子整型的相关操作

如同普通的操作集合一样(load(), store(), exchange(), compare_exchange_weak(), 和
compare_exchange_strong())，在 std::atomic<int> 和 std::atomic<unsigned long long> 也是有一套完整的操作可以供使用：fetch_add(), fetch_sub(), fetch_and(), fetch_or(),fetch_xor()，还有复合赋值方式((+=, -=, &=, |=和^=)，以及++和--(++x, x++, --x和x--)。

### 5.2.6 std::atomic<>主要类的模板

为了使用 std::atomic<UDT> (UDT是用户定义类型)：
* 这个类型必须有拷贝赋值运算符。这就意味着这个类型不能有任何虚函数或虚基类，以及必须使用编译器创建的拷贝赋值操作。不仅仅是这些，自定义类型中所有的基类和非静态数据成员也都需要支持拷贝赋值操作。
* 这(基本上)就允许编译器使用memcpy()，或赋值操作的等价操作，因为它们的实现中没有用户代码。
* 最后，这个类型必须是“位可比的”(bitwise equality comparable)。

![7.png](7.png)

### 5.2.7 原子操作的释放函数

在不同的原子类型中
也有等价的非成员函数存在。大多数非成员函数的命名与对应成员函数有关，但是需要“atomic_”作为前缀(比如， std::atomic_load() )。这些函数都会被不同的原子类型所重载。在指定一个内存序列标签时，他们会分成两种：一种没有标签，另一种将“_explicit”作为后缀，并且需要一个额外的参数，或将内存顺序作为标签，亦或只有标签。参数传入指针。

{% hihghlight c++ %}
std::shared_ptr<Foo> p;
void process_global_data()
{
    std::shared_ptr<Foo> local = std::atomic_load(&p);
}
void update_global_data()
{
    std::shared_ptr<Foo> local(new Foo);
    std::atomic_store(&p, local);
}
{% endhighlight %}

## 5.3 同步操作和强制排序

{% highlight c++ %}

void reader_thread()
{
    while(!data_ready.load());                    //1
    std::cout<<"The answer="<<data[0]<<'\n';      //2
}

void writer_thread()
{
    data.push_back(42);                           //3
    data_ready.store(true);                       //4
}
{% endhighlight %}

强制访问顺序是由对 std::atomic<bool> 类型的data_ready变量进行操作完成的；这些操作通过先行发生(happens-before)和同步发生(synchronizes-with)确定必要的顺序。写入数据③的操作，在写入data_ready标志④的操作前发生，并且读取标志①发生在读取数据②之前。当data_ready①为true，写操作就会与读操作同步，建立一个“先行发生”关系。因为“先行发生”是可传递的，所以写入数据③先行于写入标志④，这两个行为又先行于读取标志的操作①，之前的操作都先行于读取数据②。

### 5.3.1 同步发生

“同步发生”只能在原子类型之间进行操作。“同步发生”的基本想法是：在变量x进行适当标记的原子写操作W，同步与对x进行适当标记的原子读操作，读取的是W操作写入的内容；或是在W之后，同一线程上的原子写操作对x写入的值；亦或是任意线程对x的一系列原子读-改-写操作。

如果线程A存储了一个值，并且线程B读取了这个值，线程A的存储操作与线程B的载入操作就是同步发生的关系

### 5.3.2 先行发生

“先行发生”关系是一个程序中，基本构建块的操作顺序；它指定了某个操作去影响另一个操作。

{% highlight c++ %}

void fun(int a,int b)
{
    std::cout<<a<<" "<<b<<'\n';
}

int getnum()
{
    static int num = 0;
    return ++num;
}

fun(getnum(),getnum());

{% endhighlight %}

c++并不保证函数参数中的执行顺序。所以这里可能会输出2 1也可能会输出1 2。

从基本层面上讲，线程间的先行比较简单，并且依赖与同步关系:如果操作A在一个线程上，与另一个线程上的操作B同步，那么A就线程间先行于B。这同样是一个传递关系：如果A线程间先行于B，并且B线程间先行于C，那么A就线程间先行于C。

### 5.3.3 原子操作的内存顺序

这里有六个内存序列选项可应用于对原子类型的操作：memory_order_relaxed,
memory_order_consume, memory_order_acquire, memory_order_release,
memory_order_acq_rel, 以及memory_order_seq_cst。除非你为特定的操作指定一个序列选项，要不内存序列选项对于所有原子类型默认都是memory_order_seq_cst。虽然有六个选项，但是它们仅代表三种内存模型：
* 排序一致序列(sequentially consistent)，
* 获取-释放序列(memory_order_consume, memory_order_acquire, memory_order_release和memory_order_acq_rel)
* 自由序列(memory_order_relaxed)。

x86或x86-64架构默认就是排序一致序列。